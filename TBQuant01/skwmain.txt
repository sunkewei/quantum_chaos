
//------------------------------------------------------------------------
// 简称: skwmain
// 名称: skwmain
// 类别: 公式应用
// 类型: 用户应用
// 输出: Void
//------------------------------------------------------------------------
Params
	
Vars
	//此处添加变量
	Series<Numeric> local_low_raw;
	Series<Numeric> local_high_raw;
	Series<Numeric> local_low;
	Series<Numeric> local_high;
	Series<Numeric> close_average;
	Series<Numeric> average_trend;
	Series<Numeric> stddev;
	Numeric percent_base;
	Numeric percent_factor;
	Numeric percent_devidor(5);
	Bool pricecrossover;
	Bool pricecrossunder;
	Numeric trend_factor;
	Series<Numeric> decision;
	Series<Numeric> general_signal(0);
	Series<Numeric> on_extreme(0);
	Series<Numeric> extreme_sign(0);
	Series<Numeric> cross_up(0);
	Numeric cross_up_sum(0);
	Series<Numeric> cross_down(0);
	Numeric cross_down_sum(0);
	Series<Numeric> accu(0);
	Series<Numeric> hl_length(1000);
	
	//Series<Numeric> abs_change;
	//Series<Numeric> abs_change_avg;

	Bool buy_entry_flag;
	Bool sell_entry_flag;
	Series<Numeric> holdings(0);
	Numeric units;
	Numeric stddev_base(5);
	Numeric stddev_now;
	Bool stdnormal(True);
	
Defs
	//此处添加公式函数
	Numeric getProperInterval(Numeric x)
	{
		return IntPart(x/BarInterval);
	}
	
	Numeric getBase()
	{
		if(BarInterval==1){
			return 5;
		}
		If(BarInterval ==5){
			return 8;
		}
		If(BarInterval ==15){
			return 13;
		}
		If(BarInterval ==30){
			return 29;
		}
		Return 5;
		 
	}
	

Events
	//此处实现事件函数
	
	//初始化事件函数，策略运行期间，首先运行且只有一次，应用在订阅数据等操作
	OnInit()
	{	
		

	}

	//在所有的数据源准备完成后调用，应用在数据源的设置等操作
	OnReady()
	{
		
	}

	//在新bar的第一次执行之前调用一次，参数为新bar的图层数组
	OnBarOpen(ArrayRef<Integer> indexs)
	{

	}
	//Bar更新事件函数，参数indexs表示变化的数据源图层ID数组
	OnBar(ArrayRef<Integer> indexs)
	{
		hl_length = getProperInterval(2000);
		units = intpart(30000/(Close*ContractUnit/10));
		stddev_base = Round(Average(Max(Close*0.01, StandardDev(Close,getProperInterval(2000)))/Close, getProperInterval(CurrentBar))*1000, 0);
		general_signal = general_signal[1];
		if(MarketPosition == 0){
			general_signal = 0;
		}
		//percent factor
		percent_base = Abs(PercentChange(close, 2)*10000)/5;
		percent_factor = max(percent_base/getBase(),1);
		//extreme_sign
		on_extreme = 0;
		if(Close==Highest(Close,getProperInterval(4000))){
			on_extreme = 1;
		}
		if(Close==Lowest(Close,getProperInterval(4000))){
			on_extreme = -1;
		}
		extreme_sign = sign(Summation(on_extreme, getProperInterval(2000)));
		
		//calculate crossover and crossunder
		stddev = Max(Close*0.01, StandardDev(Close,getProperInterval(2000)));
		stddev_now = stddev*1000/Close/stddev_base;
		stdnormal = stddev_now<=1;
		if(not stdnormal){
			hl_length = hl_length[1]+1;
		}else{
			hl_length = hl_length[1]-1;
		}
		hl_length = max(getProperInterval(2000), min(getProperInterval(8000), hl_length));
		
		close_average = (Highest(Close, getProperInterval(hl_length)) + Lowest(Close, getProperInterval(hl_length)))/2;// Average(Close, 1000);
		//close_average = (SwingHigh(1, Close, getProperInterval(1000), getProperInterval(BarCount)) + SwingLow(1, Close, getProperInterval(1000), getProperInterval(BarCount)))/2;// Average(Close, 1000);
		average_trend = Sign(close_average-close_average[1]);
		if(average_trend == 0){
			average_trend = average_trend[1];
		}
		
		
		local_high_raw = close_average + stddev;
		local_low_raw = close_average - stddev;
		local_high = Average(local_high_raw, getProperInterval(70));
		local_low = Average(local_low_raw, getProperInterval(70));
		
		
		cross_up=0;
		cross_down = 0;
		cross_up_sum = Summation(cross_up, getProperInterval(500));
		cross_down_sum = Summation(cross_down, getProperInterval(500));
		pricecrossover = CrossOver(Close,local_low);	
		pricecrossunder = CrossUnder(Close,local_high);
		
		if(pricecrossover and cross_up_sum==0 and general_signal==1 and PositionProfit>0){
			Buy(units, close);
			cross_up = 1;
			general_signal = general_signal+1;
		}
		if(pricecrossunder and cross_down_sum==0 and general_signal==2 and (not stdnormal)){
			Sell(units, close);
			cross_down = -1;
			general_signal = general_signal-1;
		}
		
		
		if(pricecrossunder and cross_down_sum==0 and general_signal==-1 and PositionProfit>0){
			SellShort(units, close);
			cross_down = -1;
			general_signal = general_signal-1;
		}
		if(pricecrossover and cross_up_sum==0 and general_signal==-2 and (not stdnormal)){
			BuyToCover(units, close);
			cross_up = 1;
			general_signal = general_signal+1;
		}
		
		//trend_factor
		trend_factor = Sign(close-close_average) + average_trend;// Sign(close_average-close_average[1]);
		if(trend_factor!=0){
			trend_factor = Sign(trend_factor);
		}
		
		
		//decision
		If(trend_factor>0){
			decision = decision[1] + Exp(percent_factor-1)/getProperInterval(1000);
		}Else If(trend_factor<0){
			decision = decision[1] - Exp(percent_factor-1)/getProperInterval(1000);
		}Else{
			decision = decision[1];
		}
		
		decision = Sign(decision) * Min(2, Abs(decision));
		
		
		PlotNumeric("lhigh", local_high, 0,White,0);
		PlotNumeric("llow", local_low, 0,White,0);
		PlotNumeric("avg", close_average, 0,Yellow,0);
		
		//PlotString("direction", Text(round(percent_factor,0)), High, Yellow);
		
		if(Abs(decision)>=2 ){
			decision = decision+extreme_sign;
			if(Abs(decision)>=3){
				decision = Sign(decision)*2;
			}Else{
				decision = Sign(decision)*1.97;
			}
		}
		
		
		
		
		
		buy_entry_flag = decision>=2 and stdnormal;//and direction>5;	
		sell_entry_flag = decision<=-2 and stdnormal;// and direction<-5;
		if( buy_entry_flag
			and MarketPosition==0){
			Buy(units, close);
			general_signal = 1;
		}
		if( decision<=0.1 
				and MarketPosition==1){
			Sell(0, close);
			general_signal=0;
		}
		if( sell_entry_flag
			and MarketPosition==0){
			SellShort(units, close);
			general_signal=-1;
		}
		if(	decision>=-0.1
			and MarketPosition==-1){
			BuyToCover(0, close);
			general_signal = 0;
		}
		
		
		if(general_signal >= 1){
			//PlotBool("buy", True, Low);
			
		}
		if(general_signal <= -1){
			//PlotBool("sell", False, Low);
		}
		
		/*
		if(decision ==2){
			PlotBool("buy", True, Low);
			
		}
		if(stdnormal){
			PlotBool("sell", False, Low);
		}
		*/
		if(abs(general_signal)>abs(general_signal[1])){
			accu = Sign(general_signal);
		}Else If(abs(general_signal)>0){
			accu = accu[1]+Sign(general_signal);
		}Else{
			accu = 10000;
		}
		//PlotString("accu", Text(round(Average(stddev/Close, getProperInterval(10000)), 3)), high);
		//PlotString("accu", Text(round(trend_factor, 0)), high);
		//PlotNumeric("accu", accu);
		//PlotNumeric("accuabs", abs(accu));
	}
		
	
	
	//持仓更新事件函数，参数pos表示更新的持仓结构体
	OnPosition(PositionRef pos)
	{
		
	}

	//策略账户仓更新事件函数，参数pos表示更新的账户仓结构体
	OnStrategyPosition(PositionRef pos)
	{
		
	}

	//委托更新事件函数，参数ord表示更新的委托结构体
	OnOrder(OrderRef ord)
	{
		
	}

	//成交更新事件函数，参数ordFill表示更新的成交结构体
	OnFill(FillRef ordFill)
	{
		
	}

	//定时器更新事件函数，参数id表示定时器的编号，millsecs表示定时间的间隔毫秒值
	OnTimer(Integer id,Integer intervalMillsecs)
	{
		
	}

	//通用事件触发函数，参数evtName为事件名称，参数evtValue为事件内容
	OnEvent(StringRef evtName,MapRef<String,String> evtValue) 
	{
		
	}

	//当前策略退出时触发
	OnExit()
	{

	}

	


//------------------------------------------------------------------------
// 编译版本	2020/07/09 133253
// 版权所有	timecompression
// 更改声明	TradeBlazer Software保留对TradeBlazer平台
//			每一版本的TradeBlazer公式修改和重写的权利
//------------------------------------------------------------------------

