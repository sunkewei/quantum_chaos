/*  **************************************
 * Nuclear Version 8.0
 @ Dependency
 skw_formal_print_array
 skw_formal_array_functions
 skw_steps_calc
 
 ******************************************/

Params 
	Numeric slots(1);
	//Numeric diff_threshold(0.2);

Vars
	Numeric latestoperation(4);
	String outputfilename;
	String freqfilename;
	
  
	
	Numeric timeholder;
	String pinzhong;
	Numeric today_lowerlimit;
	Numeric	today_upperlimit;
	
	Numeric chiduo;
	Numeric chikong;
	Numeric currentAsk;
	Numeric currentBid;
	
	Numeric realbuy;
	
	
	
	Numeric length(0);
	String next_buy_sign;
	
	 
	NumericSeries last_close;
	Numeric long_scale;
	Numeric short_scale;
	NumericSeries ma_adapt_10; 
	NumericSeries ma_adapt_9; 
	NumericSeries ma_adapt_8; 
	NumericSeries ma_adapt_7; 
	NumericSeries ma_adapt_6; 
	NumericSeries ma_adapt_5; 
	NumericSeries ma_adapt_4; 
	NumericSeries ma_adapt_3; 
	NumericSeries ma_adapt_2; 
	NumericSeries ma_adapt_1;
	NumericSeries ma_adapt_total_raw;
	
	NumericSeries ma_adapt_total;
	
	
	NumericSeries bias_decision;
	NumericSeries ma_adapt_diff; 
	
	Numeric color;
	NumericSeries dk_accu_posi;
	NumericSeries dk_accu_negi;
	NumericSeries dk_accu;
	NumericSeries buy_sell_indicator;
	
	Numeric span;
	Numeric price_span;
	NumericSeries dynamic_length;

	Bool continuous_buy_condition;
	Bool quit_buy_condition;
	
	Bool continuous_sell_condition;
	Bool quit_sell_condition;
	
	Bool raw_continuous_buy_condition;
	Bool raw_quit_buy_condition;
	
	Bool raw_continuous_sell_condition;
	Bool raw_quit_sell_condition;
	
	
	NumericSeries accu_factor(1);
	Numeric length_limit(300);
	
	NumericSeries increase_diff;
	NumericSeries increase_step_factor(1);
	
	NumericSeries turning_price;
	
	Numeric avg_distance;
	Numeric idx;
	NumericSeries range_factor;
	NumericSeries range_counter;	
	
	NumericSeries price_factor(1);
	NumericSeries avg_price;
	NumericSeries turning_increase;
	NumericSeries price_position;
	NumericSeries status(0);
	NumericSeries real_status(0);
	NumericSeries real_turning_price(0);
	NumericSeries real_turning_price_upper(0);
	NumericSeries real_turning_price_down(0);
	
	NumericSeries buy_price(0);
	NumericSeries sell_price(0);
	NumericSeries profit;
	
	String totalsign;
	
	
	
	
	  
Begin
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Initialization 
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	////////////////////////////////
	// Initialize Variables
	//////////////////////////////// 
	realbuy = 2;
	pinzhong = Symbol();
	outputfilename = "c:/status/"+pinzhong;
	freqfilename = "c:/freq/"+pinzhong;
	timeholder = CurrentTime();
	totalsign = pinzhong+"_total";
	
	
	
	////////////////////////////////////
	// Calculate ma_adapt_total
	///////////////////////////////////
	length_limit = 200;
	last_close = open;//LinearRegValue(open, 10, 0); 
	avg_price = Average(last_close, 5);
	length = dynamic_length[1];
	long_scale = 30;
	short_scale = 2;
	
	ma_adapt_10 = AdaptiveMovAvg(last_close, length, short_scale, long_scale); 
	ma_adapt_9 = AdaptiveMovAvg(last_close, length*9/10, short_scale, long_scale); 
	ma_adapt_8 = AdaptiveMovAvg(last_close, length*8/10, short_scale, long_scale); 
	ma_adapt_7 = AdaptiveMovAvg(last_close, length*7/10, short_scale, long_scale); 
	ma_adapt_6 = AdaptiveMovAvg(last_close, length*6/10, short_scale, long_scale); 
	ma_adapt_5 = AdaptiveMovAvg(last_close, length*5/10, short_scale, long_scale); 
	ma_adapt_4 = AdaptiveMovAvg(last_close, length*4/10, short_scale, long_scale); 
	ma_adapt_3 = AdaptiveMovAvg(last_close, length*3/10, short_scale, long_scale); 
	ma_adapt_2 = AdaptiveMovAvg(last_close, length*2/10, short_scale, long_scale); 
	ma_adapt_1 = AdaptiveMovAvg(last_close, length*1/10, short_scale, long_scale); 	
	//ma_adapt_total = (ma_adapt_1 + ma_adapt_2 + ma_adapt_3 + ma_adapt_4 + ma_adapt_5 + ma_adapt_6 + ma_adapt_7 + ma_adapt_8 + ma_adapt_9 + ma_adapt_10)/10;
	
	ma_adapt_total = ma_adapt_5;
	ma_adapt_total = AdaptiveMovAvg(ma_adapt_total, 10, 2, 30);
	
	////////////////////////////////////
	// price position
	///////////////////////////////////
	price_position = Round((last_close-Lowest(last_close, 200))*100/(Highest(last_close, 200)-Lowest(last_close, 200)),0);
	
	
	////////////////////////////////////
	// increase_step_factor calculate
	///////////////////////////////////
	increase_diff = Abs(last_close - last_close[1]);
	increase_step_factor = Max(increase_diff/Median(increase_diff, 30), 0.5) - 1;
	
	////////////////////////////////////
	// Calculate bias decision
	///////////////////////////////////
	price_span = Max(Average(Abs(close[1]-close[2]), 50), PriceScale);
	ma_adapt_diff = (ma_adapt_total -  ma_adapt_total[2])/price_span;
	span = Highest(Abs(ma_adapt_diff), 50)/1.5;
	if(ma_adapt_diff > span){
		bias_decision = 1;
	}Else if(ma_adapt_diff < -1*span){
		bias_decision = -1;
	}Else if(ma_adapt_diff < 0){
		bias_decision = -0.1;
	}Else if(ma_adapt_diff > 0){
		bias_decision = 0.1;
	}Else{
		bias_decision = 0;
	}
	////////////////////////////////////
	// Calculate accu
	///////////////////////////////////
	
	if(bias_decision*bias_decision[1] <=0 ){
		accu_factor = 1;
		dynamic_length = length_limit;
		
	}Else{
		dynamic_length = Max(Round(dynamic_length[1]*0.9, 0), 10);
		if ((last_close - last_close[1]) * bias_decision > 0){
			accu_factor = accu_factor[1]*1.1;
		}
	}
	dk_accu_posi = ma_adapt_diff;	
	if(ma_adapt_diff > 0 and ma_adapt_diff[1] > 0){
		dk_accu_posi = dk_accu_posi+dk_accu_posi[1];
	}else{
		dk_accu_posi = 0;
	}
	
	dk_accu_negi = ma_adapt_diff;
	if(ma_adapt_diff < 0 and ma_adapt_diff[1] < 0){
		dk_accu_negi = dk_accu_negi+dk_accu_posi[1];
	}else{
		dk_accu_negi = 0;
	}
		
	dk_accu = dk_accu[1] + ma_adapt_diff; 
	if(dk_accu*bias_decision <0){
		dk_accu = dk_accu + ma_adapt_diff*accu_factor*6;
	}
	
	If(dk_accu>0 and dk_accu[1]<0){
		dk_accu = dk_accu_posi;
	}
	If(dk_accu<0 and dk_accu[1]>0){
		dk_accu = dk_accu_negi;
	}
	
	
	////////////////////////////////////
	// Calculate avg_distance
	///////////////////////////////////
	If(dk_accu*dk_accu[1] <=0){
	    turning_price = last_close;
		
		if((last_close - turning_price[1])*turning_increase[1]>0){
			real_turning_price = real_turning_price[1];
			real_turning_price_upper = real_turning_price_upper[1];
			real_turning_price_down = real_turning_price_down[1];
		}else{
			real_turning_price = turning_price;
			real_turning_price_upper = real_turning_price + open*0.03;
			real_turning_price_down = real_turning_price-open*0.03;
		}
		If(last_close > real_turning_price[1] ){
			turning_increase = 1;
		}Else If(last_close < real_turning_price[1]){
			turning_increase = -1;
		}Else{
			turning_increase = 0;
		}
		range_factor = 3;
	}else{
		turning_price = turning_price[1];
		/*if(Abs(last_close-turning_price) > open*0.05){
			turning_price = Sign(last_close - open*0.05)*Abs(last_close - open*0.05);
		}*/
		If( turning_increase[1] > 0){
			turning_increase = turning_increase + 1;
		}Else If(turning_increase[1]<0){
			turning_increase = turning_increase -1;
		}Else{
			turning_increase = 0;
		}
		range_factor = Max(range_factor[1]*0.95, 0.4);
	}
	
	
	
	
	
	
	
	
	
	
	for idx=0 to 29{
		avg_distance = avg_distance + Abs(last_close[idx] - real_turning_price[idx]);
	}
	avg_distance = Max(avg_distance/30, open*0.01*range_factor);
	
	If(last_close < real_turning_price - avg_distance){
		range_counter = range_counter[1] - 1;
	}Else If(last_close > real_turning_price + avg_distance){
		range_counter = range_counter[1] + 1;
	}Else{
		range_counter = 0;
	}
	
	
	
	 
	
	////////////////////////////////////
	// Calculate buy_sell_indicator
	///////////////////////////////////
	
	buy_sell_indicator = 0;
	
	If(
		dk_accu>0
		&& Abs(turning_increase)>70
		//&&real_turning_price + avg_distance > real_turning_price_upper
		&& price_position >=90
		&& last_close > real_turning_price + avg_distance
		&& range_counter>10
		&& avg_price > avg_price[5] && avg_price[5] > avg_price[10]
		){
		
			buy_sell_indicator = 1;
	
	}Else If(
		dk_accu<0
		&& Abs(turning_increase)>70
		//&&real_turning_price - avg_distance < real_turning_price_down
		&& price_position <=10
		&& last_close < real_turning_price - avg_distance
		&& range_counter<-10
		&& avg_price < avg_price[5] && avg_price[5] < avg_price[10]
		){  
			
			buy_sell_indicator = -1;
	}
	
	
	
	
	raw_continuous_buy_condition = buy_sell_indicator>0 ; 
	
	raw_quit_buy_condition = ((last_close < real_turning_price - avg_distance ) or (turning_increase>100 and last_close < real_turning_price ));
	
	raw_continuous_sell_condition = buy_sell_indicator<0 ;
	
	raw_quit_sell_condition = ((last_close > real_turning_price + avg_distance ) or (turning_increase<-100 and last_close > real_turning_price))
							;
							
	status = Sign(status[1])*(Abs(status)+1);
	//status = status[1];
	If(raw_continuous_buy_condition and status[1]==0){
			status = 1;
	}Else If(raw_quit_buy_condition and status[1]>0){
			status = 0;
	}
	
	If(raw_continuous_sell_condition and status[1]==0 ){
			status = -1;
	}Else If(raw_quit_sell_condition and status[1]<0){
			status = 0;
	}
	 
	SetTBProfileString(totalsign,"status", Text(status));
	
	continuous_buy_condition =  raw_continuous_buy_condition;	
	quit_buy_condition = raw_quit_buy_condition;
	continuous_sell_condition = raw_continuous_sell_condition;
	quit_sell_condition = raw_quit_sell_condition;
	
	 
	
	buy_price = buy_price[1];
	sell_price = sell_price[1];
	
	
	if(realbuy ==2){
		If(continuous_buy_condition and CurrentContracts==0){
				buy_price = open;
				Buy(slots, open);
				FileAppend(freqfilename,SymbolType+"_"+Text(Date)+"_buy");
				
		}Else If(quit_buy_condition){
				Sell(0, open);
		}
		If(continuous_sell_condition and CurrentContracts==0 ){
				sell_price = open;
				SellShort(slots, open);
				FileAppend(freqfilename,SymbolType+"_"+Text(Date)+"_sell"); 
		}Else If(quit_sell_condition){
				BuyToCover(0, open);
		}
	}
	profit = 0;
	if(status>0){
		profit = Round((close-buy_price)*100/buy_price, 1);
	}
	if(status<0){
		profit = Round((sell_price-close)*100/sell_price, 1);
	}
	
	
	If( BarStatus==2){
		FileAppend(outputfilename,Text(CurrentDate)+"-"+Text(CurrentTime*1000000)); 
		
		
		If(dk_accu==0){
		    FileAppend(outputfilename,"0");
		}Else{
			FileAppend(outputfilename,Text(dk_accu/Abs(dk_accu)));
		}
		
		FileAppend(outputfilename,Text(turning_increase));
		FileAppend(outputfilename, Text(price_position));
		
		If(last_close > real_turning_price + avg_distance){
			FileAppend(outputfilename, Text(1));
		}Else If(last_close < real_turning_price - avg_distance){
			FileAppend(outputfilename, Text(-1));
		}Else{
			FileAppend(outputfilename, Text(0));
		}
		
		
		FileAppend(outputfilename, Text(range_counter));
		
		If(avg_price > avg_price[5] && avg_price[5] > avg_price[10]){
			FileAppend(outputfilename, Text(1));
		}Else If(avg_price < avg_price[5] && avg_price[5] < avg_price[10]){
			FileAppend(outputfilename, Text(-1));
		}Else{
			FileAppend(outputfilename, Text(0));
		}
		
	
		
		
		
		
		FileAppend(outputfilename,pinzhong);
		
		FileAppend(outputfilename,Text(profit));
		
		FileAppend(outputfilename,Text(Sign(dk_accu)));
		
		FileAppend(outputfilename,Text(status));
		  
	}  
	color=white;
	if(status>0){
		color = green;
	}
	if(status<0){
		color = red;
	}
	PlotString("dkaccu", Text(Round(profit,1)), high, color); 
	//PlotString("dkaccu", Text(turning_increase), high, color); 
	//PlotNumeric("m10", ma_adapt_total, 0, yellow, 0);
	
	PlotNumeric("tpu", real_turning_price + avg_distance, 0, color, 0);
	PlotNumeric("tpm", real_turning_price - avg_distance, 0, color, 0);
	PlotNumeric("tpuu", real_turning_price_upper, 0, white, 0);
	PlotNumeric("tpd", real_turning_price_down, 0, white, 0);
	//PlotNumeric("tpr", real_turning_price, 0, color, 0);
	
	if(dk_accu>0){
		color = green; 
	}
	if(dk_accu<0){
		color = red;
	}
	
	PlotNumeric("tp", turning_price , 0, color, 0);
	
	
	
End

//------------------------------------------------------------------------
// 编译版本	GS2015.12.25
// 用户版本	2016/08/01 11:33:20
// 版权所有	straightup
// 更改声明	TradeBlazer Software保留对TradeBlazer平台
//			每一版本的TradeBlazer公式修改和重写的权利
//------------------------------------------------------------------------